% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/shapeConstr.R, R/shapeConstr.default.R,
%   R/shapeConstr.factor.R
\name{shapeConstr}
\alias{shapeConstr}
\alias{shapeConstr.default}
\alias{shapeConstr.factor}
\title{Specify shape constraints}
\usage{
shapeConstr(x, shape, ...)

\method{shapeConstr}{default}(x, shape, intercept = FALSE, ...)

\method{shapeConstr}{factor}(x, shape, intercept = FALSE, ...)
}
\arguments{
\item{x}{An object representing a design matrix of predictor variables, typically basis functions. See details for supported objects.}

\item{shape}{A character vector indicating one or several shape-constraints. See details for supported shapes.}

\item{...}{Additional parameters passed to or from other methods.}

\item{intercept}{For the default method, a logical value indicating if the design matrix includes an intercept. In most cases, it will be automatically extracted from \code{x} but this can be used to override it.}
}
\value{
A list containing the constraint matrix \code{Cmat}, and lower/upper bound vectors (\code{lb} and \code{ub} respectively).
}
\description{
Builds a constraint matrix and bound coefficients for shape-constraints on a set of coefficients. This is a generic function designed to be used in the \link[=buildCmat]{constr} interface. It allows methods for a wide range of regression terms (see details).
}
\details{
This function is used to specify shape constraints on terms in a \code{cirls} model. Shapes can refer to the relation between the coefficients of several variables in a matrix (for instance dummy variables to impose shapes on the levels of a factor), or to the shape of a smooth term (such as splines). note that this function can also be used to easily specify non-negativity or non-positivity constraints. See below for the list of implemented shapes and the examples section for several use cases.
\subsection{Usage}{

The recommended usage is to use this function through a call to \code{shape} on a term in the \link[=buildCmat]{constr} interface. This method is then called internally to create the constraint matrix and bound vectors. However, \code{shapeConstr} can also be called directly on a matrix-like object to manually build or inspect the constraint matrix.

The parameters necessary to build the constraint matrix (e.g. \code{knots} and \code{ord} for splines) are typically extracted from the \code{x} object. This is also true for the \code{intercept} for most of the object, except for the default method for which it can be useful to explicitly provide it. In a typical usage in which \code{shapeConstr} is called from the \code{constr} argument, \code{intercept} is automatically determined from the \link[stats:glm]{glm} formula.
}

\subsection{Allowed shapes}{

The \code{shape} argument allows to define a specific shape for the association between the expanded term in \code{x} and the response of the regression model. This shape can describe the relation between coefficients for the default method, or the shape of the smooth term for spline bases. At the moment, six different shapes are supported, with up to three allowed simultaneously (one from each category):
\itemize{
\item \code{"pos"} or \code{"neg"}: Positive/Negative. Applies to the full association.
\item \code{"inc"} or \code{"dec"}: Monotonically Increasing/Decreasing.
\item \code{"cvx"} or \code{"ccv"}: Convex/Concave.
}
}

\subsection{Available methods}{

In addition to the default method, \code{shapeConstr} currently supports several objects, creating an appropriate shape-constraint matrix depending on the object. The full list can be obtained by \code{methods(shapeConstr)}.
\subsection{General}{
\itemize{
\item \code{\link[=factor]{factor()}}: for categorical variables. Extract the \link[stats:contrasts]{contrasts} to define the constraint matrix. Here the \code{intercept} argument has the same interpretation as in the default method, i.e. if set to \code{TRUE} it means the \code{glm} model doesn't include an intercept externally to the factor. Note that, in this case, a simple dummy coding is done in R.
}
}

\subsection{From the \link[splines:splines-package]{splines} package}{
\itemize{
\item \link[splines:bs]{bs}: B-splines.
\item \link[splines:ns]{ns}: Natural splines.
}
}

\subsection{From the \link[dlnm:dlnm-package]{dlnm} package}{
\itemize{
\item \link[dlnm:onebasis]{onebasis}: General method for basis functions generated in the package.
\item \link[dlnm:ps]{ps}: Penalised splines (P-Splines).
}
}

}
}
\examples{
###############################################################################
# Non-negative coefficient example with the london dataset

library(splines)

### Association between Ozone and mortality
# Nonnegative constraint on Ozone
model <- glm(death ~ o3, data = london, family = "quasipoisson",
  method = "cirls.fit", cons = ~ shape(o3, "pos"))

# Coefficient and confidence interval
coef(model)[2]
confint(model)[2,]

# Comparing to an unconstrained model
umodel <- uncons(model)
coef(umodel)[2]
confint(umodel)[2,]
###############################################################################
# Monotone strata levels with the warming dataset

### Fit the model

# Non-decreasing constraint on decadal strata
model <- glm(anomaly ~ decade, data = warming, method = "cirls.fit",
  cons = ~ shape(decade, "inc"))

# Plot result
plot(anomaly ~ year, data = warming, xlab = "", ylab = "Temperature anomaly")
lines(warming$year, predict(model), col = 2, lwd = 2)

### Extract results

# Coefficients and confidence intervals
betas <- coef(model)
v <- vcov(model)
cis <- confint(model)

# Degrees of freedom: represent number of strata change
# ?edf
edf(model)

### Compare with an unconstrained model

# Refit the model without constraints
umodel <- uncons(model)

# Add result
lines(warming$year, predict(umodel), col = 3, lwd = 2, lty = 2)

##############################################################################
# Monotone splines with the warming dataset

library(splines)

# Define a natural spline basis
basis <- ns(warming$year, df = 10)

### Constrained model

# Non-decreasing splines
model <- glm(anomaly ~ basis, data = warming, method = "cirls.fit",
  cons = ~ shape(basis, "inc"))

# Plot result
plot(anomaly ~ year, data = warming, xlab = "", ylab = "Temperature anomaly")
lines(warming$year, predict(model), col = 2, lwd = 2)

### Unconstrained model
umodel <- uncons(model)
lines(warming$year, predict(umodel), col = 3, lwd = 2, lty = 2)

}
\references{
Zhou, S. & Wolfe, D. A., 2000. On derivative estimation in spline regression. \emph{Statistica Sinica} \strong{10}, \strong{93â€“108}.
}
\seealso{
\link[=buildCmat]{buildCmat} detailing the \code{constr} interface.
}
